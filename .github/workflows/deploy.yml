name: Manual Deploy

on:
  workflow_dispatch:
    inputs:
      ref:
        description: "Git ref to deploy (branch, tag, or SHA)"
        required: true
        default: "main"
        type: string
      environment:
        description: "GitHub Environment gate"
        required: true
        default: "production"
        type: choice
        options:
          - production
      mode:
        description: "Deployment mode"
        required: true
        default: "deploy"
        type: choice
        options:
          - deploy
          - validate_only
          - restart_only
          - rollback_previous
      confirm:
        description: "Type `deploy-production` to confirm"
        required: true
        type: string
      run_connection_check:
        description: "Run `edgelord check connection` before service action"
        required: true
        default: true
        type: boolean
      run_live_check:
        description: "Run `edgelord check live` before restart"
        required: true
        default: true
        type: boolean
      change_note:
        description: "Optional deploy note (shown in logs)"
        required: false
        default: ""
        type: string
      # Strategy toggles
      strategy_single_condition:
        description: "Enable single_condition strategy"
        required: false
        default: true
        type: boolean
      strategy_market_rebalancing:
        description: "Enable market_rebalancing strategy"
        required: false
        default: true
        type: boolean
      strategy_combinatorial:
        description: "Enable combinatorial strategy"
        required: false
        default: false
        type: boolean
      # Runtime overrides
      min_edge:
        description: "Minimum edge threshold (e.g., 0.05)"
        required: false
        default: ""
        type: string
      min_profit:
        description: "Minimum profit threshold (e.g., 0.50)"
        required: false
        default: ""
        type: string
      max_exposure:
        description: "Maximum total exposure (e.g., 5000)"
        required: false
        default: ""
        type: string
      max_position:
        description: "Maximum position per market (e.g., 500)"
        required: false
        default: ""
        type: string
      dry_run:
        description: "Dry run mode (detect but don't trade)"
        required: false
        default: false
        type: boolean
      telegram_enabled:
        description: "Enable Telegram notifications"
        required: false
        default: false
        type: boolean
      dugout:
        description: "Use dugout for secrets injection (requires dugout on VPS)"
        required: false
        default: true
        type: boolean

permissions:
  contents: read

concurrency:
  group: manual-deploy-${{ inputs.environment }}
  cancel-in-progress: false

env:
  CARGO_TERM_COLOR: always

jobs:
  deploy:
    name: Deploy to VPS
    runs-on: ubuntu-latest
    environment: ${{ inputs.environment }}

    steps:
      - name: Checkout selected ref
        uses: actions/checkout@v4
        with:
          ref: ${{ inputs.ref }}

      - name: Resolve release SHA
        id: release
        run: echo "sha=$(git rev-parse HEAD)" >> "$GITHUB_OUTPUT"

      - name: Confirm deployment intent
        run: |
          set -euo pipefail
          expected="deploy-${{ inputs.environment }}"
          if [[ "${{ inputs.confirm }}" != "$expected" ]]; then
            echo "Confirmation mismatch. Expected: $expected"
            exit 1
          fi

      - name: Print deployment plan
        run: |
          echo "Mode: ${{ inputs.mode }}"
          echo "Environment: ${{ inputs.environment }}"
          echo "Ref: ${{ inputs.ref }}"
          if [[ -n "${{ inputs.change_note }}" ]]; then
            echo "Change note: ${{ inputs.change_note }}"
          fi

      - name: Install Rust toolchain
        if: ${{ inputs.mode == 'deploy' }}
        uses: dtolnay/rust-toolchain@stable

      - name: Build release binary
        if: ${{ inputs.mode == 'deploy' }}
        run: cargo build --release

      - name: Run tests (release profile)
        if: ${{ inputs.mode == 'deploy' }}
        run: cargo test --release

      - name: Configure SSH
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT }}
          DEPLOY_SSH_KEY: ${{ secrets.DEPLOY_SSH_KEY }}
          DEPLOY_KNOWN_HOSTS: ${{ secrets.DEPLOY_KNOWN_HOSTS }}
        run: |
          set -euo pipefail
          test -n "$DEPLOY_HOST"
          test -n "$DEPLOY_SSH_PORT"
          test -n "$DEPLOY_SSH_KEY"
          test -n "$DEPLOY_KNOWN_HOSTS"

          mkdir -p ~/.ssh
          printf '%s\n' "$DEPLOY_SSH_KEY" > ~/.ssh/id_ed25519
          chmod 600 ~/.ssh/id_ed25519
          printf '%s\n' "$DEPLOY_KNOWN_HOSTS" > ~/.ssh/known_hosts
          chmod 600 ~/.ssh/known_hosts

      - name: Upload release artifacts
        if: ${{ inputs.mode == 'deploy' }}
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          RELEASE_SHA: ${{ steps.release.outputs.sha }}
        run: |
          set -euo pipefail
          test -n "$DEPLOY_USER"
          # Upload binary
          scp -i ~/.ssh/id_ed25519 -P "$DEPLOY_SSH_PORT" \
            target/release/edgelord \
            "$DEPLOY_USER@$DEPLOY_HOST:/tmp/edgelord-$RELEASE_SHA"
          # Upload dugout vault (if exists)
          if [[ -f .dugout.toml ]]; then
            scp -i ~/.ssh/id_ed25519 -P "$DEPLOY_SSH_PORT" \
              .dugout.toml \
              "$DEPLOY_USER@$DEPLOY_HOST:/tmp/dugout-$RELEASE_SHA.toml"
          fi
          # Upload production config
          scp -i ~/.ssh/id_ed25519 -P "$DEPLOY_SSH_PORT" \
            deploy/config.prod.toml \
            "$DEPLOY_USER@$DEPLOY_HOST:/tmp/config-$RELEASE_SHA.toml"

      - name: Deploy and restart
        env:
          DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
          DEPLOY_SSH_PORT: ${{ secrets.DEPLOY_SSH_PORT }}
          DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
          DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
          RELEASE_SHA: ${{ steps.release.outputs.sha }}
          MODE: ${{ inputs.mode }}
          RUN_CONNECTION_CHECK: ${{ inputs.run_connection_check }}
          RUN_LIVE_CHECK: ${{ inputs.run_live_check }}
          # Strategy toggles
          STRATEGY_SINGLE_CONDITION: ${{ inputs.strategy_single_condition }}
          STRATEGY_MARKET_REBALANCING: ${{ inputs.strategy_market_rebalancing }}
          STRATEGY_COMBINATORIAL: ${{ inputs.strategy_combinatorial }}
          # Runtime overrides
          MIN_EDGE: ${{ inputs.min_edge }}
          MIN_PROFIT: ${{ inputs.min_profit }}
          MAX_EXPOSURE: ${{ inputs.max_exposure }}
          MAX_POSITION: ${{ inputs.max_position }}
          DRY_RUN: ${{ inputs.dry_run }}
          TELEGRAM_ENABLED: ${{ inputs.telegram_enabled }}
          DUGOUT: ${{ inputs.dugout }}
        run: |
          set -euo pipefail
          test -n "$DEPLOY_USER"
          test -n "$DEPLOY_PATH"

          # Build strategies list from toggles
          STRATEGIES=""
          [[ "$STRATEGY_SINGLE_CONDITION" == "true" ]] && STRATEGIES="single_condition"
          [[ "$STRATEGY_MARKET_REBALANCING" == "true" ]] && STRATEGIES="${STRATEGIES:+$STRATEGIES,}market_rebalancing"
          [[ "$STRATEGY_COMBINATORIAL" == "true" ]] && STRATEGIES="${STRATEGIES:+$STRATEGIES,}combinatorial"

          ssh \
            -i ~/.ssh/id_ed25519 \
            -p "$DEPLOY_SSH_PORT" \
            "$DEPLOY_USER@$DEPLOY_HOST" \
            "DEPLOY_PATH='$DEPLOY_PATH' DEPLOY_USER='$DEPLOY_USER' RELEASE_SHA='$RELEASE_SHA' MODE='$MODE' RUN_CONNECTION_CHECK='$RUN_CONNECTION_CHECK' RUN_LIVE_CHECK='$RUN_LIVE_CHECK' BINARY_STAGING='/tmp/edgelord-$RELEASE_SHA' STRATEGIES='$STRATEGIES' MIN_EDGE='$MIN_EDGE' MIN_PROFIT='$MIN_PROFIT' MAX_EXPOSURE='$MAX_EXPOSURE' MAX_POSITION='$MAX_POSITION' DRY_RUN='$DRY_RUN' TELEGRAM_ENABLED='$TELEGRAM_ENABLED' DUGOUT='$DUGOUT' bash -s" <<'REMOTE'
            set -euo pipefail

            # Ensure cargo binaries (dugout) are in PATH
            export PATH="$HOME/.cargo/bin:$PATH"

            CONFIG_PATH="$DEPLOY_PATH/config/config.toml"
            DUGOUT_PATH="$DEPLOY_PATH/.dugout.toml"
            CURRENT_LINK="$DEPLOY_PATH/current"
            RELEASE_DIR="$DEPLOY_PATH/releases/$RELEASE_SHA"
            PREV_TARGET="$(readlink -f "$CURRENT_LINK" || true)"

            # Ensure directories exist
            mkdir -p "$DEPLOY_PATH"/{config,releases,data}

            # Change to deploy directory so dugout can find .dugout.toml
            cd "$DEPLOY_PATH"

            # Update dugout vault (always sync from repo)
            if [[ -f "/tmp/dugout-$RELEASE_SHA.toml" ]]; then
              mv "/tmp/dugout-$RELEASE_SHA.toml" "$DUGOUT_PATH"
              echo "Updated dugout vault"
            fi

            # Copy config if missing (preserve existing customizations)
            if [[ ! -f "$CONFIG_PATH" && -f "/tmp/config-$RELEASE_SHA.toml" ]]; then
              mv "/tmp/config-$RELEASE_SHA.toml" "$CONFIG_PATH"
              echo "Created initial config"
            else
              rm -f "/tmp/config-$RELEASE_SHA.toml"
            fi

            run_checks() {
              # Config check doesn't need secrets
              "$CURRENT_LINK/edgelord" check config --config "$CONFIG_PATH"

              # Connection and live checks need secrets via dugout
              local CMD_PREFIX=""
              if [[ "$DUGOUT" == "true" && -f "$DUGOUT_PATH" ]]; then
                CMD_PREFIX="dugout run --"
              fi

              if [[ "$RUN_CONNECTION_CHECK" == "true" ]]; then
                $CMD_PREFIX "$CURRENT_LINK/edgelord" check connection --config "$CONFIG_PATH"
              fi
              if [[ "$RUN_LIVE_CHECK" == "true" ]]; then
                $CMD_PREFIX "$CURRENT_LINK/edgelord" check live --config "$CONFIG_PATH"
              fi
            }

            restart_service() {
              # Build extra args for service install
              EXTRA_ARGS=""
              [[ -n "$STRATEGIES" ]] && EXTRA_ARGS="$EXTRA_ARGS --strategies $STRATEGIES"
              [[ -n "$MIN_EDGE" ]] && EXTRA_ARGS="$EXTRA_ARGS --min-edge $MIN_EDGE"
              [[ -n "$MIN_PROFIT" ]] && EXTRA_ARGS="$EXTRA_ARGS --min-profit $MIN_PROFIT"
              [[ -n "$MAX_EXPOSURE" ]] && EXTRA_ARGS="$EXTRA_ARGS --max-exposure $MAX_EXPOSURE"
              [[ -n "$MAX_POSITION" ]] && EXTRA_ARGS="$EXTRA_ARGS --max-position $MAX_POSITION"
              [[ "$DRY_RUN" == "true" ]] && EXTRA_ARGS="$EXTRA_ARGS --dry-run"
              [[ "$TELEGRAM_ENABLED" == "true" ]] && EXTRA_ARGS="$EXTRA_ARGS --telegram-enabled"
              [[ "$DUGOUT" == "true" ]] && EXTRA_ARGS="$EXTRA_ARGS --dugout"

              sudo "$CURRENT_LINK/edgelord" service install --config "$CONFIG_PATH" --user "$DEPLOY_USER" --working-dir "$DEPLOY_PATH" $EXTRA_ARGS
              sudo systemctl restart edgelord
              sleep 2
              sudo systemctl is-active edgelord
            }

            rollback() {
              echo "Deployment failed; attempting rollback"
              if [[ -n "${PREV_TARGET:-}" && -d "$PREV_TARGET" ]]; then
                ln -sfn "$PREV_TARGET" "$CURRENT_LINK"
                if [[ -x "$CURRENT_LINK/edgelord" ]]; then
                  restart_service || true
                fi
              fi
            }

            if [[ ! -f "$CONFIG_PATH" ]]; then
              echo "Missing config at $CONFIG_PATH"
              exit 1
            fi

            case "$MODE" in
              deploy)
                trap rollback ERR
                mkdir -p "$RELEASE_DIR"
                install -m 755 "$BINARY_STAGING" "$RELEASE_DIR/edgelord"
                rm -f "$BINARY_STAGING"
                ln -sfn "$RELEASE_DIR" "$CURRENT_LINK"
                run_checks
                restart_service
                trap - ERR
                ;;
              validate_only)
                if [[ ! -x "$CURRENT_LINK/edgelord" ]]; then
                  echo "Missing binary at $CURRENT_LINK/edgelord"
                  exit 1
                fi
                run_checks
                ;;
              restart_only)
                if [[ ! -x "$CURRENT_LINK/edgelord" ]]; then
                  echo "Missing binary at $CURRENT_LINK/edgelord"
                  exit 1
                fi
                restart_service
                ;;
              rollback_previous)
                CURRENT_TARGET="$(readlink -f "$CURRENT_LINK" || true)"
                if [[ -n "${CURRENT_TARGET:-}" ]]; then
                  PREVIOUS_TARGET="$(
                    ls -1dt "$DEPLOY_PATH"/releases/* 2>/dev/null \
                      | grep -v "^$CURRENT_TARGET$" \
                      | head -n 1
                  )"
                else
                  PREVIOUS_TARGET="$(ls -1dt "$DEPLOY_PATH"/releases/* 2>/dev/null | head -n 1)"
                fi
                if [[ -z "${PREVIOUS_TARGET:-}" ]]; then
                  echo "No previous release found for rollback"
                  exit 1
                fi
                ln -sfn "$PREVIOUS_TARGET" "$CURRENT_LINK"
                run_checks
                restart_service
                ;;
              *)
                echo "Unsupported mode: $MODE"
                exit 1
                ;;
            esac

            if [[ ! -x "$CURRENT_LINK/edgelord" ]]; then
              echo "Missing binary at $CURRENT_LINK/edgelord"
              exit 1
            fi

            # Ensure edgelord is available in PATH
            sudo ln -sf "$CURRENT_LINK/edgelord" /usr/local/bin/edgelord

            echo "Mode $MODE completed successfully"
          REMOTE
